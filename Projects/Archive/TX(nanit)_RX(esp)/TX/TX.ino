#include <SPI.h>      // бібліотека SPI потрібна обов'язково, включена в NanitLib
#include "nRF24L01.h" // обидві бібліотеки необхідні для nRF24L01
#include "RF24.h"

RF24 radio(52,53); // піни на чисту MEGA 2560; для Nanit можна інші обрати

byte address[][6] = {"1Node", "2Node", "3Node", "4Node", "5Node", "6Node"}; //возможные номера труб

uint8_t counter[4], got[3]; //змінні для буферів пердачі та Сallback

void setup() {
  Serial.begin(9600);        //порт для відслідкування даних в Serial
  radio.begin();             //запуск модуля
  radio.setAutoAck(1);       //режим підтвердження прийому, 1 вкл 0 вмкн
  radio.setRetries(0,3);     //(час між спробою "достукатись", кількість спроб)
  radio.enableAckPayload();  //дозволити передачу даних у відповідь
  radio.setPayloadSize(4);   //розмір пакету в БАЙТАХ

  
  radio.openWritingPipe(address[0]);  // мы - труба 0, открываем канал для передачи данных
  radio.setChannel(0x60);         //обираємо канал (в якомму нема шумів!)

  radio.setPALevel (RF24_PA_MAX); //рівень потужності передатчика. На вибір RF24_PA_MIN, RF24_PA_LOW, RF24_PA_HIGH, RF24_PA_MAX
  radio.setDataRate (RF24_2MBPS); //швидкість обміну. На вибір RF24_2MBPS, RF24_1MBPS, RF24_250KBPS
  /*
  при нижчій швидкості маємо вищу чутливість та дальність!!
  мінімальна швидкість для Duplex обміну 1 МБ/с
  ПАРАМЕТРИ швидкості та передачі мають бути однакові на обох модулях
  */

  radio.powerUp(); //запуск модуля
  radio.stopListening();  //вимикаємо прослуховування ефіру, оскільки це передатчик
}

void loop(void) {
  for(uint8_t i = 0;i<4;i++){counter[i]=random(0,255);}//рандомайзер щоб буфер передачі не був порожній
  
  if(radio.write(&counter, 4)) // перевірка чи передались дані
  {
    Serial.println("Sent: " +  // виведення буферу для передачі
    String(counter[0]) + " " + 
    String(counter[1]) + " " + 
    String(counter[2]) + " " + 
    String(counter[3]));
    /*
    Передача даних працює наступним чином:
    1) Якщо дані не надіслані, то нічого не відбувається і виводиться відповідна інформація;
    2) Дані, які відправлені виводяться в Serial Monitor
    3) Після надсилання даних читається дані, як відповідь на надсилання, та записуються у відповідний буфер
    */
    if(!radio.available()){Serial.print("NO Callback");} // перевірка "Callback": якщо нема даних то виводиться повідомлення
    else                                                 // якщо дані приходять
    {
      while (radio.available())
      {
        radio.read(&got, 3);            // запис отриманих даних в буфер
        Serial.println("Callback: " +   // виведення даних Serial Monitor
        String(got[0]) + " " + 
        String(got[1]) + " " + 
        String(got[2]) + " ");
      }
    }
  }
  else{Serial.println("Fail Transmit!!!");}  // повідомлення у випадку помилки передачі даних
  delay(1000); // затримка циклу loop на 1 секунду для наглядній ілюстрації прийому передачі
  /*
  ВАЖЛИВО:
  Якщо в коді для передатчика стоїть затримка на передачу, то для приймача затримка не потрібна взагалі
  В данному зразку зроблен механізм таким чином: приймач нічого не робить поки не будуть надходити дані взагалі
  */
}
